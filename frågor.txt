(Jag siktar på att få betyg VG)


*Vad är pull respektive push?*

Kommandot pull används i git för att hämta och få ändringar i remote repositoryn.

Push används när man vill skicka ändringar till remote repositoryn.



*När använder man log respektive status?*

Log används när man vill se historiken av alla commits som har gjorts på branchen. Den visar också hash (eller commit ID-sträng), namn
på författaren samt datumet och tiden commiten gjordes.

Status används när man vill se om nya filer har blivit skapade, modifierade eller slängda från branchen. Den kommer
också visa om vissa filer ligger eller inte ligger i staging area (untracked files) samt allmänt ge förslag på kommandon man
kan använda (såsom git add, git restore för modifierade filer osv.).
Den visar också längst upp vilken branch man är inne på, och om den är "up to date" med remote
repositoryn och dess branch.



*Vad är en Git branch och varför är de viktiga?*

En Git Branch är som en referens till en commit som man själv, eller någon annan har gjort. I en branch (som inte är
är huvudbranchen) har man möjligheten att modifiera samt testa göra ändringar i filer, och göra commits som kanske
sedan inte bör lagras i huvudprojektet, men som kan läggas till i huvudprojektet (med hjälp av kommandot git merge).



*Det finns flera sätt att rulla tillbaka koden till ett tidigare tillstånd. Förklara skillnaden och motivera när man 
skulle använda den ena eller andra metoden. Ge exempel på de kommandon du använder för att göra detta och visa att 
det fungerar, vilken output du fick från git-kommandona.*

Det finns tre typer av kommandon som man kan använda för att återställa kod i en fil till ett tidigare tillstånd.
Det är bl.a. 'git restore', 'git revert' och 'git reset --hard'.

För att använda sig av 'git restore' så kan man simpelt skriva kommandot såhär:
git restore --source=HEAD~[nummer] [filnamn]
eller
git restore --source=[hash] [filnamn]
En fördel med att använda 'git restore' är att commit historiken inte påverkas, utan det är bara ändringar i working
directory (kan också vara ändringar i staged area om man använder --staged), och därför kan det i det fallet vara
smidigt att använda just 'git restore'. Däremot bör man sedan commita på nytt.
Jag har använt kommandot 'git restore' som exempel med filen 'changeWithGitRestore.java', där man kan se i commit
historiken hur det ser ut att använda 'git restore'.

När man använder sig av 'git revert' så ser kommandot ut såhär:
git revert [hash]
Vad som sker när man använder det kommandot är att koden i filen återställs till den commiten man valde, och man får
en ny commit, där det står 'Revert' samt allt annat som det stog i commiten man valde. Detta tyddliggör för de som
jobbar i repositoryn från vilken tillstånd filen blev återställd från, och därför kan det vara en fördel att
använda just 'git revert' i de fallen.
Jag har använt kommandot 'git revert' med exempelfilen 'changeWithGitRevert.java',
och man kan se att det står 'Revert "I now added How are you text to ChangeWithGitRevert.java"', och återställde koden från när det stog "Created
ChangeWithGitRever.java file and added Hello there text"

Slutligen har vi 'git reset --hard', och kommandot ser ut såhär:
git reset --hard HEAD~[nummer]
eller
git reset --hard [hash]
Detta kommer att ta bort alla commits ovanför den commiten man valde och man får tillbaka ändringarna från den commit
man valde. Att använda sig av 'git reset --hard' för att återställa koden i en fil kan vara bra om man inte vill
behålla någon commit ovanför den valda commiten och också samtidigt vill återställa koden i filen. Däremot går det inte
att få tillbaka de commiten ovanför samt den föregående koden innan du återställde den, och därför måste man vara 
väldigt försiktig när man använder sig av 'git reset --hard'.
Jag använde exempelfilen 'changeWithGitResetHard.java' för kommandot 'git reset --hard'. Jag hade en commit med hash 'f43c2b0', som var precis 
ovanför den med hash 'c16062f', men den togs bort efter att jag använde 'git reset --hard'



*Beskriv och jämför hur man kan använda git rebase och git merge i ett scenario där flera utvecklare jobbar på olika feature branches. 
Diskutera fördelarna och nackdelarna med båda teknikerna, samt hur de påverkar historiken.*

När man har jobbat i en feature branch och gjort ändringar som inte är uppdaterade med huvudbranchen så kan man använda sig av kommandot 'git 
merge'. Vad git merge gör är att hämta ändringar från feature branchen och lägger in det i huvudbranchen. Vad git merge också gör är att visa
commit historiken i den ordningen de faktiskt gjordes. Man kan se det som en fördel med git merge är att den bevarar commit historiken så som
den faktiskt var, och då vet man när ändringarna gjordes exakt. Däremot kan det snabbt bli "orent" i commit historiken när man har gjort flera
merges, och då kan det bli svårt att hänga med alla merges.

Man kan också använda sig av kommandot 'git rebase' för att hämta de senaste ändringarna från en branch. Det som rebase gör annorlunda från merge
är att den ändrar på commit historiken. Den ser till att hämta commitsen från den andra branchen och lägga den ovanför all annan av den aktuella 
branchens commit history. Detta kan ge en känsla av en renare historik, som är lättare att följa, och därför kan 'git rebase' ses som en fördel
över 'git merge'.
Man bör däremot undvika att använda 'git rebase' med branches där flera utvecklare jobbar, då ändringen av commit historiken kan vara
vilseledande, och kan ge större chans till att man får konfliker. I sådana fall kan 'git rebase' ses som en nackdel. 
