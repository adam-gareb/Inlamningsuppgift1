(Jag siktar på att få betyg VG)

(Det är här i main branchen jag har den senaste versionen av frågor.txt, inte i restoreCode-branch)


*Vad är pull respektive push?*

Kommandot pull används i git för att hämta och få ändringar i remote repositoryn.

Push används när man vill skicka ändringar till remote repositoryn.



*När använder man log respektive status?*

Log används när man vill se historiken av alla commits som har gjorts på branchen. Den visar också hash (eller commit ID-sträng), namn
på författaren samt datumet och tiden commiten gjordes.

Status används när man vill se om nya filer har blivit skapade, modifierade eller slängda från branchen. Den kommer
också visa om vissa filer ligger eller inte ligger i staging area (untracked files) samt allmänt ge förslag på kommandon man
kan använda (såsom git add, git restore för modifierade filer osv.).
Den visar också längst upp vilken branch man är inne på, och om den är "up to date" med remote
repositoryn och dess branch.



*Vad är en Git branch och varför är de viktiga?*

En Git branch är som en referens till en commit som man själv eller någon annan har gjort. Den kan också visa alla tidigare commits.
I en branch har man möjligheten att modifiera och göra ändringar i filer, och göra commits som lägger till det i repository, som senare kan 
läggas in i remote repository. Man kan ha flera branches i en repository, och man kan ha så kallade 'feature-branches' för att göra ändringar 
som inte finns i huvudbranchen, men som senare kan läggas in i huvudbranchen.



*Det finns flera sätt att rulla tillbaka koden till ett tidigare tillstånd. Förklara skillnaden och motivera när man 
skulle använda den ena eller andra metoden. Ge exempel på de kommandon du använder för att göra detta och visa att 
det fungerar, vilken output du fick från git-kommandona.*

Det finns tre typer av kommandon som man kan använda för att återställa kod i en fil till ett tidigare tillstånd.
Det är bl.a. 'git restore', 'git revert' och 'git reset --hard'.

För att använda sig av 'git restore' så kan man skriva kommandot såhär:
git restore --source=HEAD~[nummer] [filnamn]
eller
git restore --source=[hash] [filnamn]
En fördel med att använda 'git restore' är att commit historiken inte påverkas, utan det är bara ändringar i working
directory (kan också vara ändringar i staged area om man använder --staged), och därför kan det i det fallet vara
smidigt att använda just 'git restore'. Däremot bör man sedan commita på nytt.
Jag har använt kommandot 'git restore' som exempel med filen 'changeWithGitRestore.java', där man kan se i commit
historiken hur det ser ut att använda 'git restore'.

När man använder sig av 'git revert' så ser kommandot ut såhär:
git revert [hash]
Vad som sker när man använder det kommandot är att koden i filen återställs till den commiten man valde, och man får
en ny commit, där det står 'Revert' samt allt annat som det stog i commiten man valde. Detta tyddliggör för de som
jobbar i repositoryn från vilken tillstånd filen blev återställd från, och därför kan det vara en fördel att
använda just 'git revert' i de fallen.
Jag har använt kommandot 'git revert' med exempelfilen 'changeWithGitRevert.java',
och man kan se att det står 'Revert "I now added How are you text to ChangeWithGitRevert.java"', och återställde koden från när det stog "Created
ChangeWithGitRever.java file and added Hello there text"

Slutligen har vi 'git reset --hard', och kommandot ser ut såhär:
git reset --hard HEAD~[nummer]
eller
git reset --hard [hash]
Detta kommer att ta bort alla commits ovanför den commiten man valde och man får tillbaka ändringarna från den commit
man valde. Att använda sig av 'git reset --hard' för att återställa koden i en fil kan vara bra om man inte vill
behålla någon commit ovanför den valda commiten och också samtidigt vill återställa koden i filen. Däremot går det inte
att få tillbaka de commiten ovanför samt den föregående koden innan du återställde den, och därför måste man vara 
väldigt försiktig när man använder sig av 'git reset --hard'.
Jag använde exempelfilen 'changeWithGitResetHard.java' för kommandot 'git reset --hard'. Jag hade en commit med hash 'f43c2b0', som var precis 
ovanför den med hash 'c16062f', men den togs bort efter att jag använde 'git reset --hard'



*Beskriv och jämför hur man kan använda git rebase och git merge i ett scenario där flera utvecklare jobbar på olika feature branches. 
Diskutera fördelarna och nackdelarna med båda teknikerna, samt hur de påverkar historiken.*

När man har jobbat i en feature branch och gjort ändringar som inte är uppdaterade med huvudbranchen så kan man använda sig av kommandot 'git 
merge'. Vad git merge gör är att hämta ändringar från en annan branch och lägger in det i branchen man är inne i. 
Vad git merge också gör är att visa commit historiken i den ordningen de faktiskt gjordes. 
Man kan se det som en fördel med git merge är att den bevarar commit historiken så som den faktiskt var, och då vet man när ändringarna 
gjordes exakt. Däremot kan det snabbt bli "orent" i commit historiken när man har gjort flera merges, och då kan det bli svårt att hänga 
med i alla merges, och det har 'git merge' som nackdel.
Jag har använt mig av 'git merge' i 'Inlamningsuppgift1-VG-uppgifter' repositoryn, och har mergat från branchen 'merge-branch' till 'master' 
branchen.
När man kollar i commit historiken så ser man att den är lagt i den ordning de gjordes i realtid.
d0f4381 (HEAD -> master) Resolved conflict and decided to keep what's up text from master   (från master, efter mergen från merge-branch)
22bd265 Added what's up text in Main.java		                                    (från master)
6f3b9ff (merge-branch) added how are you text in Main.java                                  (från merge-branch)
3e046fb Created Main.java that prints out Hello there                                       (från master)


Man kan också använda sig av kommandot 'git rebase' för att hämta de senaste ändringarna från en branch. Det som rebase gör annorlunda från merge
är att den ändrar på commit historiken. Den ser till att hämta commitsen från den andra branchen och lägga den ovanför all annan av den aktuella 
branchens commit history. Detta kan ge en känsla av en renare historik, som är lättare att följa, och därför kan 'git rebase' ses som en fördel
över 'git merge'.
Man bör däremot undvika att använda 'git rebase' med branches där flera utvecklare jobbar, då ändringen av commit historiken kan vara
vilseledande, och kan ge större chans till att man får konfliker. I sådana fall kan 'git rebase' ses som en nackdel. 
Jag har använt mig av 'git rebase' med master branch och 'rebase-branch' i 'Inlamningsuppgift1-VG-uppgifter' repository, där jag gjorde 
rebase i 'rebase-branch' för att få uppdateringar från master.
Då fick jag en konflikt i 'c309e73', och behövde ändra i den raden som är markerad med '<<<<<', '====' och '>>>>>', och därmed bestämma mig för 
vilken av de två raderna jag vill behålla.
När jag var klar med att hantera konfliketet i filen så körde jag 'git rebase --continue', för att låta rebase kommandot fortsätta.
När man sedan kollar med 'git log' eller 'git log --oneline', så ser man tydligt de commit som har hänt och kommit från master branchen då de
alla ligger ovanpå all annan commit i rebase-branch (även om jag ändrade fram och tillbaka mellan master och rebase-branch).
b882d9c (HEAD -> rebase-branch) Resolved conflict with rebase and decided to keep Hope you are well text  (rebase-branch efter jag gjorde rebase)
ba02367 (master) added Hoping all is well text in master branch                                           (master)
d0f4381 Resolved conflict and decided to keep what's up text from master                                  (master)
22bd265 Added what's up text in Main.java                                                                 (master)
6f3b9ff (merge-branch) added how are you text in Main.java                                                (master)
3e046fb Created Main.java that prints out Hello there                                                     (master)
